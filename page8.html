<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Interactive Game Map Navigator</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<!-- Tailwind CSS CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">

<style>
  /* Custom styles for the dark theme and responsive map/slider track */
  body {
    font-family: 'Inter', sans-serif;
  }
  /* Custom marker icon styles for a game vibe */
  .custom-pin {
    width: 24px;
    height: 24px;
    background-color: #fca5a5; /* Red-300 */
    border: 3px solid #dc2626; /* Red-600 */
    border-radius: 50% 50% 50% 0;
    transform: rotate(-45deg);
    position: relative;
    box-shadow: 0 0 5px rgba(220, 38, 38, 0.7);
    cursor: pointer;
    transition: all 0.2s ease-in-out;
  }
  .custom-pin.active {
    background-color: #3b82f6; /* Blue-500 */
    border-color: #1d4ed8; /* Blue-700 */
    box-shadow: 0 0 10px rgba(59, 130, 246, 1);
    transform: scale(1.3) rotate(-45deg); /* Pop on activation */
    z-index: 1000;
  }
  .custom-pin::after {
    content: '';
    width: 6px;
    height: 6px;
    margin: 9px 0 0 9px;
    background-color: white;
    position: absolute;
    border-radius: 50%;
  }

  /* Slider track and thumb styling */
  input[type=range]::-webkit-slider-runnable-track { background: #4b5563; border-radius: 8px; height: 8px; }
  input[type=range]::-moz-range-track { background: #4b5563; border-radius: 8px; height: 8px; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); transition: background 0.15s ease-in-out; }
  input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #3b82f6; cursor: pointer; box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); transition: background 0.15s ease-in-out; }
  /* Custom scrollbar for results */
  #places-list::-webkit-scrollbar { width: 6px; }
  #places-list::-webkit-scrollbar-track { background: #1f2937; }
  #places-list::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
</style>
</head>
<body class="bg-gray-900 text-gray-100 min-h-screen flex flex-col">

  <!-- Header and Controls Section (Fixed/Sticky for Mobile Access) -->
  <header class="p-4 bg-gray-800 shadow-xl z-10 sticky top-0">
    <h1 class="text-2xl font-extrabold text-center text-blue-400 mb-4 tracking-wider">Interactive Map Key</h1>
    <div id="controls" class="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4">

      <!-- Locate Button -->
      <button id="btn" class="w-full sm:w-auto bg-green-600 hover:bg-green-700 transition duration-150 text-white font-bold py-3 px-6 rounded-xl shadow-lg transform hover:scale-[1.02] active:scale-[0.98] focus:outline-none focus:ring-4 focus:ring-green-500/50">
        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 inline-block mr-2" viewBox="0 0 20 20" fill="currentColor">
          <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
        </svg>
        Find & Load Map Pins
      </button>

      <!-- Radius Slider -->
      <div class="flex flex-col w-full sm:w-48 p-2">
        <label class="text-sm font-semibold mb-2 flex justify-between">
          Search Radius: <span id="rangeVal" class="text-blue-400 font-bold">1000 m</span>
        </label>
        <input id="radius" type="range" min="200" max="2000" step="100" value="1000" class="w-full appearance-none h-2 bg-gray-700 rounded-lg cursor-pointer">
      </div>
    </div>
    
    <!-- Category Checkboxes (Search Filters) -->
    <div class="flex flex-wrap justify-center gap-3 p-2 bg-gray-700/50 rounded-lg mt-3 text-sm">
        <span class="text-gray-400 font-medium">Search Filters:</span>
        <label class="flex items-center space-x-1 cursor-pointer hover:text-blue-300 transition">
          <input type="checkbox" class="cat h-4 w-4 text-blue-500 rounded border-gray-600 bg-gray-900 checked:bg-blue-500" value="highway" checked>
          <span>Roads/Transit</span>
        </label>
        <label class="flex items-center space-x-1 cursor-pointer hover:text-blue-300 transition">
          <input type="checkbox" class="cat h-4 w-4 text-blue-500 rounded border-gray-600 bg-gray-900 checked:bg-blue-500" value="amenity" checked>
          <span>Amenities</span>
        </label>
        <label class="flex items-center space-x-1 cursor-pointer hover:text-blue-300 transition">
          <input type="checkbox" class="cat h-4 w-4 text-blue-500 rounded border-gray-600 bg-gray-900 checked:bg-blue-500" value="shop" checked>
          <span>Shops</span>
        </label>
        <label class="flex items-center space-x-1 cursor-pointer hover:text-blue-300 transition">
          <input type="checkbox" class="cat h-4 w-4 text-blue-500 rounded border-gray-600 bg-gray-900 checked:bg-blue-500" value="leisure" checked>
          <span>Parks/Leisure</span>
        </label>
    </div>
  </header>

  <!-- Map Container (Main Focus) -->
  <div id="map" class="w-full h-[50vh] sm:h-[60vh] z-0 shadow-inner"></div>

  <!-- Results Section -->
  <div id="places-container" class="p-4 bg-gray-900 flex-grow overflow-hidden">
    <h2 class="text-xl font-bold mb-3 border-b border-gray-700 pb-1 text-yellow-500">Map Key (Filter by Category)</h2>
    
    <!-- Category Tabs -->
    <div id="category-tabs" class="flex flex-wrap gap-2 mb-4">
      <!-- Tabs will be injected here by JS -->
    </div>

    <!-- Results List -->
    <div id="places-list" class="max-h-full overflow-y-auto space-y-2 pb-4">
        <p class="text-gray-400 text-center p-4">Tap **Find & Load Map Pins** to begin.</p>
    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
// Global state variables
const map = L.map('map');
let userMarker = null;
let routeLine = null;
let highlightGroup = []; // Stores the current route and map feature highlights
let markerGroup = L.layerGroup().addTo(map); // Layer group for all POI markers
let categorizedPlaces = {}; // Stores all fetched, processed data, grouped by category
let markerMap = new Map(); // Maps unique ID to Leaflet Marker object
let userLocation = null;
let currentActiveId = null; // ID of the currently selected place

// Define the categories and their friendly names
const CATEGORY_MAP = {
    highway: { label: 'Roads/Transit', icon: 'üõ£Ô∏è' },
    amenity: { label: 'Amenities', icon: 'üìç' },
    shop: { label: 'Shops', icon: 'üõçÔ∏è' },
    leisure: { label: 'Parks/Leisure', icon: 'üèûÔ∏è' },
};

// Initialize Map
L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '¬© OpenStreetMap contributors',
}).addTo(map);

// Event listener for radius slider display update
document.getElementById('radius').oninput = e => {
  document.getElementById('rangeVal').textContent = e.target.value + ' m';
};

// Utility function to calculate distance (in meters)
function getDistance(lat1, lon1, lat2, lon2) {
    return L.latLng(lat1, lon1).distanceTo([lat2, lon2]);
}

/**
 * Executes an Overpass API query to find nearby points of interest.
 */
async function getNearby(lat, lon, cats, dist) {
  const filters = cats.map(c => `node["${c}"](around:${dist},${lat},${lon});way["${c}"](around:${dist},${lat},${lon});`).join('');
  const query = `[out:json][timeout:25];(${filters}node["name"](around:${dist},${lat},${lon});way["name"](around:${dist},${lat},${lon}););out tags center geom;`;
  try {
    const res = await fetch("https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query));
    if (!res.ok) throw new Error("Overpass API request failed.");
    const data = await res.json();
    return data.elements.filter(e => e.tags && e.tags.name);
  } catch(error) {
    console.error("Error fetching nearby places:", error);
    document.getElementById('places-list').innerHTML = `<p class="text-red-400 text-center p-4">Could not load places: ${error.message}</p>`;
    return [];
  }
}

/**
 * Processes raw OSM elements: assigns unique ID, calculates distance, coordinates, and primary category.
 */
function processElements(userLat, userLon, els) {
    const results = {};
    for (const key in CATEGORY_MAP) {
        results[key] = [];
    }

    let idCounter = 0;

    // Process and categorize
    els.forEach(e => {
        const id = 'poi-' + idCounter++;
        const lat = e.lat || (e.center && e.center.lat) || (e.geometry && e.geometry[0] && e.geometry[0].lat);
        const lon = e.lon || (e.center && e.center.lon) || (e.geometry && e.geometry[0] && e.geometry[0].lon);

        if (!lat || !lon) return;

        // Assign a primary category based on the first match in CATEGORY_MAP order
        let primaryCat = null;
        for (const cat in CATEGORY_MAP) {
            if (e.tags[cat]) {
                primaryCat = cat;
                break;
            }
        }
        
        if (primaryCat) {
            const placeData = {
                id: id,
                name: e.tags.name,
                distance: getDistance(userLat, userLon, lat, lon),
                category: primaryCat,
                destLat: lat,
                destLon: lon,
                element: e,
            };
            results[primaryCat].push(placeData);
        }
    });

    // Sort each category by distance
    for (const cat in results) {
        results[cat].sort((a, b) => a.distance - b.distance);
    }
    
    return results;
}

/**
 * Renders custom markers for all places and stores them in markerMap.
 */
function renderMarkers(allPlaces) {
    markerGroup.clearLayers();
    markerMap.clear();

    allPlaces.forEach(place => {
        const markerIcon = L.divIcon({
            className: 'custom-pin',
            html: '',
            iconSize: [24, 24],
            iconAnchor: [12, 24],
            popupAnchor: [0, -20]
        });

        const marker = L.marker([place.destLat, place.destLon], { icon: markerIcon })
            .bindPopup(`<b>${place.name}</b><br>${CATEGORY_MAP[place.category].label}`)
            .addTo(markerGroup);

        // Attach click handler to the marker
        marker.on('click', () => {
            handlePlaceSelection(place.id, place);
        });
        
        markerMap.set(place.id, marker);
    });
}

/**
 * Renders the category tabs and attaches click handlers.
 */
function renderTabs(results) {
    const tabsContainer = document.getElementById('category-tabs');
    tabsContainer.innerHTML = '';
    
    let allCount = 0;
    const allPlaces = [];
    
    for (const key in results) {
        allPlaces.push(...results[key]);
    }

    const categories = [{ key: 'all', label: `All (${allPlaces.length})`, icon: 'üåé' }];
    
    for (const key in results) {
        const count = results[key].length;
        if (count > 0) {
            categories.push({ key: key, label: `${CATEGORY_MAP[key].label} (${count})`, icon: CATEGORY_MAP[key].icon });
        }
    }
    
    categories.forEach(cat => {
        const tabButton = document.createElement('button');
        tabButton.textContent = `${cat.icon} ${cat.label}`;
        tabButton.dataset.category = cat.key;
        tabButton.className = 'tab-btn px-3 py-1.5 text-sm font-semibold rounded-lg transition duration-150 whitespace-nowrap';
        tabButton.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-blue-600', 'hover:text-white');
        
        tabButton.onclick = () => {
            // Manage visual tab state
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white');
                btn.classList.add('bg-gray-700', 'text-gray-300');
            });
            tabButton.classList.add('bg-blue-500', 'text-white');
            tabButton.classList.remove('bg-gray-700', 'text-gray-300');

            renderList(cat.key);
        };
        tabsContainer.appendChild(tabButton);
    });

    // Automatically click the 'All' tab on initial render
    if (categories.length > 0) {
        tabsContainer.querySelector('[data-category="all"]').click();
    }
}

/**
 * Renders the results list for the currently selected category.
 */
function renderList(categoryKey) {
    const listContainer = document.getElementById('places-list');
    listContainer.innerHTML = ''; // Clear existing list

    let listItems = [];
    if (categoryKey === 'all') {
        for (const key in categorizedPlaces) {
            listItems = listItems.concat(categorizedPlaces[key]);
        }
        listItems.sort((a, b) => a.distance - b.distance);
    } else {
        listItems = categorizedPlaces[categoryKey] || [];
    }

    if (listItems.length === 0) {
        listContainer.innerHTML = `<p class="text-center text-gray-500 p-4">üö´ No places found in this category.</p>`;
        return;
    }
    
    listItems.forEach(item => {
        const distanceKm = (item.distance / 1000).toFixed(2);
        
        const div = document.createElement('div');
        div.className = 'result-item bg-gray-800 p-3 rounded-xl shadow-md border-2 border-transparent hover:border-blue-500 transition cursor-pointer';
        div.dataset.id = item.id;
        
        if (item.id === currentActiveId) {
            div.classList.add('border-blue-500', 'bg-gray-700');
            div.classList.remove('bg-gray-800');
        }

        div.innerHTML = `
            <div class="flex justify-between items-start">
                <span class="font-bold text-white">${item.name}</span>
                <span class="text-sm font-semibold text-blue-400 bg-gray-700 px-2 py-0.5 rounded-full">${distanceKm} km</span>
            </div>
            <p class="text-xs text-gray-400 mt-1">Type: ${item.element.tags[item.category] || 'General POI'}</p>
        `;
        
        // Attach click handler to the list item
        div.onclick = () => handlePlaceSelection(item.id, item);
        listContainer.appendChild(div);
    });
}

/**
 * Handles the selection of a place, whether via list click or marker click.
 */
async function handlePlaceSelection(id, itemData) {
    if (!userLocation) return;

    currentActiveId = id;

    // --- 1. Sync Visual State (Markers) ---
    markerMap.forEach((marker, markerId) => {
        const iconElement = marker.getElement().firstChild;
        if (iconElement) {
            iconElement.classList.remove('active');
        }
        if (markerId === id) {
            iconElement.classList.add('active');
            marker.openPopup();
        }
    });
    
    // --- 2. Sync Visual State (List) ---
    document.querySelectorAll('.result-item').forEach(el => {
        el.classList.remove('border-blue-500', 'bg-gray-700');
        el.classList.add('bg-gray-800');
        
        if (el.dataset.id === id) {
            el.classList.add('border-blue-500', 'bg-gray-700');
            el.classList.remove('bg-gray-800');
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    });

    // --- 3. Clear Map Highlights ---
    clearRoute();
    
    // --- 4. Draw Highlights and Route ---
    const e = itemData.element;

    // Highlight element geometry on the map (if available)
    if (e.geometry) {
        if (e.geometry.length && e.geometry[0].lat) { // Polylines/Polygons (Ways)
            const coords = e.geometry.map(p => [p.lat, p.lon]);
            const l = L.polyline(coords, { color: '#00ccff', weight: 6, opacity: 0.8 }).addTo(map);
            highlightGroup.push(l);
        }
    }

    // Draw the route
    try {
        const line = await getRoute(userLocation.lat, userLocation.lon, itemData.destLat, itemData.destLon);
        routeLine = L.polyline(line, { color: '#2ecc71', weight: 5, opacity: 0.8, dashArray: '10, 10' }).addTo(map);
        
        // Fit bounds to show both user marker and the route
        const bounds = routeLine.getBounds();
        bounds.extend(userMarker.getLatLng());
        map.fitBounds(bounds, { padding: [40, 40], maxZoom: 17 });
    } catch (error) {
        console.error("Routing error:", error.message);
        // Display route error to the user via popup
        markerMap.get(id).setPopupContent(`<b>${itemData.name}</b><br>üö´ Route Error: ${error.message}`).openPopup();
    }
}

/**
 * Clears the currently displayed route and map feature highlights.
 */
function clearRoute() {
  if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
  highlightGroup.forEach(l => map.removeLayer(l));
  highlightGroup = [];
}


/**
 * Main function to get user location and search for nearby places.
 */
async function locate() {
  document.getElementById('places-list').innerHTML = '<p class="text-center text-blue-400 animate-pulse p-4">üõ∞Ô∏è Getting your location...</p>';
  document.getElementById('category-tabs').innerHTML = ''; // Clear tabs
  clearRoute(); 
  markerGroup.clearLayers();
  currentActiveId = null; // Reset selection

  navigator.geolocation.getCurrentPosition(async pos => {
    const { latitude: lat, longitude: lon } = pos.coords;
    userLocation = { lat, lon };
    map.setView([lat, lon], 15);

    // Update user marker (Custom pulsing marker for start location)
    if (userMarker) map.removeLayer(userMarker);
    const userIcon = L.divIcon({
        className: 'user-marker-icon',
        html: '<div class="w-5 h-5 bg-yellow-500 rounded-full border-2 border-white shadow-xl animate-ping absolute"></div><div class="w-3 h-3 bg-yellow-600 rounded-full border-2 border-white"></div>',
        iconSize: [20, 20],
        iconAnchor: [10, 10]
    });
    userMarker = L.marker([lat, lon], {icon: userIcon}).addTo(map).bindPopup("Your Current Location").openPopup();

    // Get parameters
    const cats = [...document.querySelectorAll('.cat:checked')].map(c => c.value);
    const dist = document.getElementById('radius').value;
    
    document.getElementById('places-list').innerHTML = '<p class="text-center text-blue-400 animate-pulse p-4">üîç Searching for map pins...</p>';

    const els = await getNearby(lat, lon, cats, dist);

    // Process and categorize the results
    categorizedPlaces = processElements(lat, lon, els);
    const allUniquePlaces = Object.values(categorizedPlaces).flat();

    // Render Markers first for the "Game Map" feel
    renderMarkers(allUniquePlaces);

    // Render the category tabs
    renderTabs(categorizedPlaces);

    // If no places found at all
    if (allUniquePlaces.length === 0) {
        document.getElementById('places-list').innerHTML = `<p class="text-center text-gray-500 p-4">üö´ No places found within ${dist} m matching the selected filters. Try increasing the search radius.</p>`;
    }

  }, err => {
    // Location error handling
    let message = 'An unknown error occurred.';
    if (err.code === err.PERMISSION_DENIED) {
        message = 'Location access was denied. Please check browser settings.';
    } else if (err.code === err.POSITION_UNAVAILABLE) {
        message = 'Location information is unavailable.';
    }
    document.getElementById('places-list').innerHTML = `<p class="text-red-400 text-center p-4">üö´ Location Error: ${message}</p>`;
  }, { enableHighAccuracy: true });
}

// Initial Map Load
map.setView([20, 0], 2); // Default view
document.getElementById('btn').onclick = locate;
</script>
</body>
</html>

