<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Offline-Ready Map Cache Navigator</title>
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<!-- Tailwind CSS CDN -->
<script src="https://cdn.tailwindcss.com"></script>
<!-- Leaflet CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
<!-- Markercluster CSS -->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.Default.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.4.1/dist/MarkerCluster.css" />

<style>
  /* Base styles */
  body { font-family: 'Inter', sans-serif; }
  
  /* --- CUSTOM PIN STYLE (NOW PLAIN) --- */
  .custom-pin {
    width: 16px;
    height: 16px;
    /* Uniform dark gray color for a plainer look */
    background-color: #374151; 
    border: 2px solid #ffffff; 
    border-radius: 50%;
    position: relative;
    box-shadow: 0 0 2px #00000080; /* Subtle shadow */
    cursor: pointer;
    transition: all 0.2s ease-in-out;
  }
  .custom-pin.active {
    /* Retain bright highlight for the selected pin */
    background-color: #3b82f6 !important; 
    border-color: #1d4ed8 !important; 
    box-shadow: 0 0 12px rgba(59, 130, 246, 1);
    transform: scale(1.6);
    z-index: 1000;
  }

  /* Key Panel transition and size on mobile */
  #key-panel {
    transition: transform 0.3s ease-in-out;
    transform: translateX(100%); 
  }
  /* Only apply the sliding behavior on small screens */
  #key-panel.open {
    transform: translateX(0);
  }
  
  /* Hide scrollbar for category tabs on mobile */
  #category-tabs::-webkit-scrollbar { display: none; }
  #category-tabs { -ms-overflow-style: none; scrollbar-width: none; }

  /* Custom slider and scrollbar styles for dark theme */
  input[type=range]::-webkit-slider-runnable-track { background: #4b5563; border-radius: 8px; height: 8px; }
  input[type=range]::-moz-range-track { background: #4b5563; border-radius: 8px; height: 8px; }
  input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #3b82f6; cursor: pointer; margin-top: -6px; box-shadow: 0 0 5px rgba(59, 130, 246, 0.5); }
  #places-list::-webkit-scrollbar { width: 6px; }
  #places-list::-webkit-scrollbar-track { background: #1f2937; }
  #places-list::-webkit-scrollbar-thumb { background: #4b5563; border-radius: 3px; }
  
  /* Loading Indicator Styles */
  .loader {
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #3b82f6;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    animation: spin 1s linear infinite;
    margin-left: 0.5rem;
    display: inline-block;
  }
  @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
</style>
</head>
<body class="bg-gray-900 text-gray-100 h-screen overflow-hidden flex flex-col">

  <!-- Header with Title and Radius Slider -->
  <header class="p-4 bg-gray-800 shadow-xl z-20">
    <h1 class="text-2xl font-extrabold text-center text-blue-400 mb-4 tracking-wider">Offline-Ready Map Navigator</h1>
    
    <!-- Radius Slider - Remains in the fixed header area -->
    <div class="flex justify-center">
        <div class="flex flex-col w-full sm:w-64 p-2">
            <label class="text-sm font-semibold mb-2 flex justify-between">
            Search Radius (Live Search Only): <span id="rangeVal" class="text-blue-400 font-bold">1000 m</span>
            </label>
            <input id="radius" type="range" min="200" max="2000" step="100" value="1000" class="w-full appearance-none h-2 bg-gray-700 rounded-lg cursor-pointer">
        </div>
    </div>
  </header>

  <!-- Map and Key Container - uses flex to arrange map and sidebar on desktop -->
  <div class="flex-grow flex relative w-full overflow-hidden">
    <!-- Map Container - takes up full width on mobile, remaining space on desktop -->
    <div id="map" class="w-full h-full sm:flex-grow z-10"></div>

    <!-- NEW: Floating Buttons Container over the Map (Top Right) -->
    <div id="map-float-controls" class="absolute top-4 right-4 z-40 flex flex-col items-end space-y-3">
        
        <!-- Locate/Search Button (#btn) - Small, floating pin button -->
        <button id="btn" class="w-12 h-12 bg-green-600 hover:bg-green-700 transition duration-150 text-white font-bold rounded-full shadow-lg flex items-center justify-center transform hover:scale-105 active:scale-95 focus:outline-none focus:ring-4 focus:ring-green-500/50" title="Load My Location & Data">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M5.05 4.05a7 7 0 119.9 9.9L10 18.9l-4.95-4.95a7 7 0 010-9.9zM10 11a2 2 0 100-4 2 2 0 000 4z" clip-rule="evenodd" />
            </svg>
        </button>

        <!-- Toggle Key Button (#toggle-key-btn) - Small, mobile-only hamburger icon button -->
        <button id="toggle-key-btn" class="w-12 h-12 bg-blue-600 hover:bg-blue-700 transition duration-150 text-white font-bold rounded-full shadow-lg flex items-center justify-center disabled:opacity-50 sm:hidden" disabled title="Open Map Key">
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" viewBox="0 0 20 20" fill="currentColor">
                <path fill-rule="evenodd" d="M3 5a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 10a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1zM3 15a1 1 0 011-1h12a1 1 0 110 2H4a1 1 0 01-1-1z" clip-rule="evenodd" />
            </svg>
        </button>
    </div>

    <!-- Sliding Key Panel (Sidebar) -->
    <div id="key-panel" class="absolute top-0 right-0 h-full w-[90vw] sm:w-80 sm:max-w-sm sm:relative sm:transform-none sm:shadow-none sm:bg-gray-900 bg-gray-900/80 backdrop-blur-md shadow-2xl z-20 flex flex-col p-4 overflow-hidden">
      
      <div class="flex justify-between items-center mb-4 pb-2 border-b border-gray-700">
        <h2 class="text-xl font-bold text-yellow-500">Map Key & Filters</h2>
        <!-- Close button hidden on desktop -->
        <button id="close-key-btn" class="text-gray-400 hover:text-white transition p-1 rounded-full bg-gray-800 hover:bg-gray-700 sm:hidden">
          <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      
      <!-- Storage Controls and Status -->
      <div class="mb-4 p-3 bg-gray-700 rounded-xl shadow-inner text-xs flex justify-between items-center">
          <span id="storage-status" class="font-medium text-gray-300">Cache: Empty</span>
          <button id="clear-cache-btn" class="bg-red-600 hover:bg-red-700 text-white font-bold py-1 px-3 rounded-lg transition disabled:opacity-50">
              Clear Local Data
          </button>
      </div>

      <!-- Marker Visibility Filters (now vertically scrollable) -->
      <div id="marker-filters" class="mb-4 p-3 bg-gray-800 rounded-xl shadow-inner">
        <p class="font-semibold mb-2 text-gray-300 border-b border-gray-700 pb-1">Toggle Marker Visibility:</p>
        <!-- Added max-h-40 overflow-y-auto for vertical scroll -->
        <div class="flex flex-wrap gap-x-4 gap-y-2 max-h-40 overflow-y-auto p-1 -m-1">
            <p class="text-xs text-gray-500">Press 'Load' to view filters.</p>
        </div>
      </div>
      
      <!-- Category Tabs (For List Filtering) -->
      <div id="category-tabs" class="flex flex-wrap gap-2 mb-4 overflow-x-auto whitespace-nowrap hide-scroll">
        <!-- Tabs will be injected here by JS -->
      </div>
      
      <!-- Results List (Scrollable area) -->
      <div id="places-list" class="flex-grow overflow-y-auto space-y-2 pb-4">
        <p class="text-gray-400 text-center p-4">Select filters and locations will appear here.</p>
      </div>
    </div>
  </div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<!-- Markercluster JS for de-cluttering -->
<script src="https://unpkg.com/leaflet.markercluster@1.4.1/dist/leaflet.markercluster.js"></script>
<script>
// --- CONFIG & STATE ---
const MAP_DATA_CACHE = 'mapDataCache';

const map = L.map('map');
const keyPanel = document.getElementById('key-panel');
const toggleKeyBtn = document.getElementById('toggle-key-btn');
const closeKeyBtn = document.getElementById('close-key-btn');

let userMarker = null;
let routeLine = null;
let highlightGroup = []; 
// INITIALIZED MarkerClusterGroup for de-cluttering
let markerGroup = L.markerClusterGroup({
    showCoverageOnHover: false,
    zoomToBoundsOnClick: true,
    spiderfyOnMaxZoom: true
}).addTo(map); 
let categorizedPlaces = {}; 
let markerMap = new Map(); 
let userLocation = null;
let currentActiveId = null; 

// Emojis removed and icons set to empty string for a plainer look
const CATEGORY_MAP = {
    tourism: { label: 'Landmarks', icon: '', color: '#facc15' }, // Amber
    amenity: { label: 'Facilities', icon: '', color: '#ff5733' }, // Orange-Red
    shop: { label: 'Commerce', icon: '', color: '#34d399' },     // Emerald Green
    leisure: { label: 'Attractions', icon: '', color: '#3b82f6' }, // Blue
    public_transport: { label: 'Transit Stops', icon: '', color: '#ec4899' }, // Pink
    highway: { label: 'Roads/Transit', icon: '', color: '#6366f1' }, // Indigo
};

// --- INITIALIZATION & UI CONTROL ---

// Tailwind's 'sm' breakpoint is 640px
function isMobileView() {
    return window.innerWidth < 640; 
}

// Control visibility of the toggle button based on screen size
function updateKeyButtonVisibility() {
    // Only show/enable toggle button on mobile
    const shouldShowToggle = isMobileView() && !toggleKeyBtn.disabled;
    toggleKeyBtn.classList.toggle('hidden', !shouldShowToggle);
    // Only show close button on mobile
    closeKeyBtn.classList.toggle('hidden', !isMobileView());
    
    // Ensure panel is open on desktop, and only controlled by 'open' class on mobile
    if (!isMobileView()) {
        keyPanel.classList.add('open'); // Keep static panel visible
    } else if (toggleKeyBtn.disabled) {
        keyPanel.classList.remove('open'); // Hide if mobile and no data loaded
    }
}

L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
  maxZoom: 19,
  attribution: '¬© OpenStreetMap contributors',
}).addTo(map);

document.getElementById('radius').oninput = e => {
  document.getElementById('rangeVal').textContent = e.target.value + ' m';
};

// Event handlers
toggleKeyBtn.onclick = () => keyPanel.classList.toggle('open');
closeKeyBtn.onclick = () => keyPanel.classList.remove('open');
document.getElementById('btn').onclick = locate;
document.getElementById('clear-cache-btn').onclick = clearLocalData;
window.addEventListener('resize', updateKeyButtonVisibility); // Respond to screen resize

// Check cache status on load
updateStorageStatus();
updateKeyButtonVisibility();
map.setView([20, 0], 2);


// --- STORAGE MANAGEMENT ---

function saveLocalData(data) {
    try {
        localStorage.setItem(MAP_DATA_CACHE, JSON.stringify(data));
        updateStorageStatus(true);
    } catch (e) {
        console.error("Error saving to local storage:", e);
    }
}

function loadLocalData() {
    try {
        const data = localStorage.getItem(MAP_DATA_CACHE);
        if (data) {
            updateStorageStatus(true);
            // Must parse the full object, including the userLocation
            const parsed = JSON.parse(data);
            if(parsed.places && parsed.userLocation) {
                return { 
                    places: parsed.places, 
                    userLocation: parsed.userLocation 
                };
            }
        }
        updateStorageStatus(false);
        return null;
    } catch (e) {
        console.error("Error loading or parsing local storage:", e);
        clearLocalData(); // Clear corrupted data
        return null;
    }
}

function clearLocalData() {
    localStorage.removeItem(MAP_DATA_CACHE);
    categorizedPlaces = {};
    markerGroup.clearLayers();
    markerMap.clear();
    clearRoute();
    updateStorageStatus(false);
    document.getElementById('places-list').innerHTML = '<p class="text-gray-400 text-center p-4">Local cache cleared. Search for new data!</p>';
    document.querySelector('#marker-filters .flex').innerHTML = '<p class="text-xs text-gray-500">Press \'Load\' to view filters.</p>';
    document.getElementById('category-tabs').innerHTML = '';
    toggleKeyBtn.disabled = true;
    updateKeyButtonVisibility();
}

function updateStorageStatus(isCached) {
    const statusEl = document.getElementById('storage-status');
    const clearBtn = document.getElementById('clear-cache-btn');
    if (isCached) {
        statusEl.innerHTML = 'Cache: <span class="text-green-400">Data Loaded</span>';
        clearBtn.disabled = false;
    } else {
        statusEl.innerHTML = 'Cache: <span class="text-red-400">Empty</span>';
        clearBtn.disabled = true;
    }
}


// --- UTILITY FUNCTIONS ---

function getDistance(lat1, lon1, lat2, lon2) {
    return L.latLng(lat1, lon1).distanceTo([lat2, lon2]);
}

async function getRoute(lat1, lon1, lat2, lon2) {
  // Routing relies on a live connection to OSRM (or another service)
  const url = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=full&geometries=geojson`;
  const r = await fetch(url);
  const d = await r.json();
  if (!d.routes || !d.routes[0]) throw new Error("No driving route found. Check connection.");
  return d.routes[0]; 
}

function clearRoute() {
  if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
  highlightGroup.forEach(l => map.removeLayer(l));
  highlightGroup = [];
}

/**
 * Generates unique IDs, calculates distance, and assigns category/color for each element.
 */
function processElements(userLat, userLon, els) {
    const results = {};
    for (const key in CATEGORY_MAP) { results[key] = []; }

    let idCounter = 0;
    els.forEach(e => {
        const id = 'poi-' + idCounter++;
        // Determine coordinates from various OSM data structures (node, way center, geometry)
        const lat = e.lat || (e.center && e.center.lat) || (e.geometry && e.geometry[0] && e.geometry[0].lat);
        const lon = e.lon || (e.center && e.center.lon) || (e.geometry && e.geometry[0] && e.geometry[0].lon);

        if (!lat || !lon) return;
        if (!e.tags || !e.tags.name) return;

        let primaryCat = null;
        for (const cat in CATEGORY_MAP) {
            if (e.tags[cat]) { primaryCat = cat; break; } 
        }
        
        if (primaryCat) {
            const placeData = {
                id: id,
                name: e.tags.name,
                distance: getDistance(userLat, userLon, lat, lon),
                category: primaryCat,
                color: CATEGORY_MAP[primaryCat].color,
                destLat: lat,
                destLon: lon,
                element: e, 
            };
            results[primaryCat].push(placeData);
        }
    });

    for (const cat in results) { results[cat].sort((a, b) => a.distance - b.distance); }
    return results;
}

// --- RENDERING ---

function renderMarkers(allPlaces) {
    markerGroup.clearLayers();
    markerMap.clear();
    const newMarkers = [];

    allPlaces.forEach(place => {
        const markerIcon = L.divIcon({
            className: 'custom-pin-container',
            // No custom color style here, relying on fixed CSS for plain look
            html: `<div class="custom-pin"></div>`,
            iconSize: [16, 16],
            iconAnchor: [8, 8],
            popupAnchor: [0, -10]
        });

        const marker = L.marker([place.destLat, place.destLon], { 
            icon: markerIcon, 
            category: place.category 
        })
            .bindPopup(`<b>${place.name}</b><br>${CATEGORY_MAP[place.category].label} (${place.element.tags[place.category]})`);

        marker.on('click', () => {
            handlePlaceSelection(place.id, place);
            if (isMobileView()) {
                keyPanel.classList.add('open'); 
            }
        });
        
        markerMap.set(place.id, marker);
        newMarkers.push(marker);
    });
    
    // Add all markers to the cluster group at once
    markerGroup.addLayers(newMarkers);
}

function toggleMarkers() {
    const checkedCategories = new Set();
    document.querySelectorAll('#marker-filters input[type="checkbox"]:checked').forEach(input => {
        checkedCategories.add(input.value);
    });
    
    // Clear all existing markers from the map before adding back filtered ones
    markerGroup.clearLayers(); 

    const markersToShow = [];
    markerMap.forEach(marker => {
        if (checkedCategories.has(marker.options.category)) {
            markersToShow.push(marker);
        }
    });
    
    // Add filtered markers back to the cluster group
    markerGroup.addLayers(markersToShow);
    
    // Re-render the list based on the active tab and visible markers
    const activeTab = document.querySelector('.tab-btn.bg-blue-500')?.dataset.category || 'all';
    renderList(activeTab);
}

function renderFilterCheckboxes(results) {
    const filtersContainer = document.querySelector('#marker-filters .flex');
    filtersContainer.innerHTML = '';
    
    for (const key in CATEGORY_MAP) {
        if (Object.values(results).flat().some(p => p.category === key)) {
            const label = document.createElement('label');
            label.className = 'flex items-center space-x-1 text-sm cursor-pointer hover:text-white transition';
            // Use the label text, no emoji icon
            label.innerHTML = `
                <input type="checkbox" class="marker-filter h-4 w-4 rounded border-gray-600 bg-gray-900 checked:bg-current" style="color:${CATEGORY_MAP[key].color};" value="${key}" checked>
                <span>${CATEGORY_MAP[key].label}</span>
            `;
            filtersContainer.appendChild(label);
            
            label.querySelector('input').addEventListener('change', toggleMarkers);
        }
    }
}

function renderTabs(results) {
    const tabsContainer = document.getElementById('category-tabs');
    tabsContainer.innerHTML = '';
    
    const allPlaces = Object.values(results).flat();
    // Replaced emoji with plain text for 'All'
    const categories = [{ key: 'all', label: `All (${allPlaces.length})`, icon: 'Total', color: '#60a5fa' }];
    
    for (const key in results) {
        const count = results[key].length;
        if (count > 0) {
            categories.push({ key: key, label: `${CATEGORY_MAP[key].label} (${count})`, icon: '', color: CATEGORY_MAP[key].color });
        }
    }
    
    categories.forEach(cat => {
        const tabButton = document.createElement('button');
        // Check if icon is provided, otherwise just use label
        tabButton.textContent = cat.icon ? `${cat.icon} ${cat.label}` : cat.label; 
        tabButton.dataset.category = cat.key;
        tabButton.className = 'tab-btn px-3 py-1.5 text-sm font-semibold rounded-lg transition duration-150 whitespace-nowrap border-b-2 border-transparent';
        tabButton.classList.add('bg-gray-700', 'text-gray-300', 'hover:bg-gray-600');
        
        if (cat.color) {
            tabButton.style.borderBottomColor = cat.color;
            tabButton.dataset.color = cat.color;
        }

        tabButton.onclick = () => {
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('bg-blue-500', 'text-white', 'scale-105');
                btn.classList.add('bg-gray-700', 'text-gray-300');
            });
            tabButton.classList.add('bg-blue-500', 'text-white', 'scale-105');
            tabButton.classList.remove('bg-gray-700', 'text-gray-300');

            renderList(cat.key);
        };
        tabsContainer.appendChild(tabButton);
    });

    if (categories.length > 0) {
        const allBtn = tabsContainer.querySelector('[data-category="all"]');
        if(allBtn) allBtn.click();
    }
}

function renderList(categoryKey) {
    const listContainer = document.getElementById('places-list');
    listContainer.innerHTML = ''; 

    let listItems = [];
    if (categoryKey === 'all') {
        listItems = Object.values(categorizedPlaces).flat();
        listItems.sort((a, b) => a.distance - b.distance);
    } else {
        listItems = categorizedPlaces[categoryKey] || [];
    }
    
    const checkedCategories = new Set(
        [...document.querySelectorAll('#marker-filters input[type="checkbox"]:checked')].map(input => input.value)
    );
    
    const visibleItems = listItems.filter(item => checkedCategories.has(item.category));

    if (visibleItems.length === 0) {
        listContainer.innerHTML = `<p class="text-center text-gray-500 p-4">üö´ No visible places in this filter combination.</p>`;
        return;
    }
    
    visibleItems.forEach(item => {
        const distanceM = item.distance.toFixed(0);
        const specificTag = item.element.tags[item.category] || 'General POI';
        
        const div = document.createElement('div');
        div.className = 'result-item bg-gray-800 p-3 rounded-xl shadow-md border-2 border-transparent hover:border-blue-500 transition cursor-pointer';
        div.dataset.id = item.id;
        
        if (item.id === currentActiveId) {
            div.classList.add('border-blue-500', 'bg-gray-700');
            div.classList.remove('bg-gray-800');
        }

        div.innerHTML = `
            <div class="flex items-center justify-between">
                <div class="flex items-center">
                    <span class="w-2 h-2 rounded-full mr-2" style="background-color: ${item.color};"></span>
                    <span class="font-bold text-white">${item.name}</span>
                </div>
                <span class="text-sm font-semibold text-blue-400 bg-gray-700 px-2 py-0.5 rounded-full">${distanceM} m</span>
            </div>
            <p class="text-xs text-gray-400 mt-1 truncate">${specificTag}</p>
        `;
        
        div.onclick = () => handlePlaceSelection(item.id, item);
        listContainer.appendChild(div);
    });
}

async function handlePlaceSelection(id, itemData) {
    if (!userLocation) return;

    currentActiveId = id;
    const markerToHighlight = markerMap.get(id);
    
    // 1. Zoom/Pan to the marker (or cluster, if clustered)
    if (markerToHighlight) {
        // If clustered, MarkerClusterGroup provides the panAndZoom method
        markerGroup.zoomToShowLayer(markerToHighlight, () => {
            map.panTo(markerToHighlight.getLatLng());
        });
        
        // Temporarily highlight the icon
        markerMap.forEach((marker, markerId) => {
            const iconElement = marker.getElement()?.firstChild;
            if (iconElement) {
                iconElement.classList.remove('active');
            }
        });
        const iconElement = markerToHighlight.getElement()?.firstChild;
        if (iconElement) {
            iconElement.classList.add('active');
        }
    }


    // 2. Sync List Key (and open panel on mobile)
    document.querySelectorAll('.result-item').forEach(el => {
        el.classList.remove('border-blue-500', 'bg-gray-700');
        el.classList.add('bg-gray-800');
        
        if (el.dataset.id === id) {
            el.classList.add('border-blue-500', 'bg-gray-700');
            el.classList.remove('bg-gray-800');
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }
    });
    
    // Open the panel on mobile view
    if (isMobileView()) {
        keyPanel.classList.add('open'); 
    }

    // 3. Draw Feature Highlight (Simplified: thin, light gray line)
    clearRoute();
    const e = itemData.element;

    if (e.geometry && e.geometry.length && e.geometry[0].lat) { 
        const coords = e.geometry.map(p => [p.lat, p.lon]);
        // Changed to a subtle gray line, weight 6
        const l = L.polyline(coords, { color: '#888', weight: 6, opacity: 0.7 }).addTo(map);
        highlightGroup.push(l);
    }

    // 4. Calculate and Draw Route with Metrics (Simplified: thin, darker gray line, solid)
    try {
        const routeData = await getRoute(userLocation.lat, userLocation.lon, itemData.destLat, itemData.destLon);
        const line = routeData.geometry.coordinates.map(([lo, la]) => [la, lo]);
        
        const distanceKm = (routeData.distance / 1000).toFixed(1);
        const durationMin = Math.round(routeData.duration / 60);

        // Changed to dark gray, thinner, solid line
        routeLine = L.polyline(line, { color: '#555', weight: 3, opacity: 0.8, dashArray: '0' }).addTo(map);
        
        routeLine.bindPopup(`
            <b class="text-green-600">ROUTE TO ${itemData.name}</b><br>
            Distance: ${distanceKm} km<br>
            Est. Time (Car): ${durationMin} minutes
        `).openPopup();
        
        const bounds = routeLine.getBounds();
        bounds.extend(userMarker.getLatLng());
        map.fitBounds(bounds, { padding: [40, 40], maxZoom: 17 });
    } catch (error) {
        console.error("Routing error:", error.message);
        const marker = markerMap.get(id);
        if(marker) {
             marker.setPopupContent(`<b>${itemData.name}</b><br>‚ö†Ô∏è Route Error: ${error.message} (Requires Network)`).openPopup();
        }
       
    }
}


// --- MAIN LOCATION & SEARCH LOGIC ---

async function locate() {
  document.getElementById('places-list').innerHTML = '<p class="text-center text-blue-400 p-4 flex items-center justify-center">Attempting to locate... <div class="loader ml-3"></div></p>';
  toggleKeyBtn.disabled = true;
  updateKeyButtonVisibility(); // Hide button while loading

  navigator.geolocation.getCurrentPosition(async pos => {
    const { latitude: lat, longitude: lon } = pos.coords;
    userLocation = { lat, lon };
    map.setView([lat, lon], 15);

    // Update user marker
    if (userMarker) map.removeLayer(userMarker);
    const userIcon = L.divIcon({
        className: 'user-marker-icon',
        html: '<div class="w-4 h-4 bg-yellow-400 rounded-full border-2 border-white shadow-xl"></div>',
        iconSize: [16, 16],
        iconAnchor: [8, 8]
    });
    userMarker = L.marker([lat, lon], {icon: userIcon}).addTo(map).bindPopup("Your Current Location").openPopup();

    // 1. TRY LOADING FROM CACHE
    const cachedData = loadLocalData();

    // Small tolerance check (1 degree is huge, but sufficient for a simple check)
    const significantChange = (cachedData && Math.abs(cachedData.userLocation.lat - lat) > 0.0001) || (cachedData && Math.abs(cachedData.userLocation.lon - lon) > 0.0001);

    if (cachedData && !significantChange) {
        document.getElementById('places-list').innerHTML = '<p class="text-center text-green-400 p-4">‚úÖ Data loaded from local cache!</p>';
        categorizedPlaces = cachedData.places;
    } else {
        // 2. FETCH LIVE DATA IF NO CACHE OR LOCATION CHANGED SIGNIFICANTLY
        await fetchLivePoiData(lat, lon);
    }
    
    // 3. RENDER ALL DATA
    const allUniquePlaces = Object.values(categorizedPlaces).flat();

    if (allUniquePlaces.length === 0) {
        document.getElementById('places-list').innerHTML = `<p class="text-center text-gray-500 p-4">üö´ No places found.</p>`;
        toggleKeyBtn.disabled = true;
    } else {
        renderMarkers(allUniquePlaces);
        renderFilterCheckboxes(categorizedPlaces);
        renderTabs(categorizedPlaces);
        toggleKeyBtn.disabled = false;
        // Panel opens by default here, if mobile view, it slides open
        if (isMobileView()) {
            keyPanel.classList.add('open');
        }
    }
    updateKeyButtonVisibility(); // Show button if data loaded and mobile view

  }, err => {
    let message = 'An unknown error occurred.';
    if (err.code === err.PERMISSION_DENIED) { message = 'Location access was denied.'; } 
    else if (err.code === err.POSITION_UNAVAILABLE) { message = 'Location information is unavailable.'; }
    document.getElementById('places-list').innerHTML = `<p class="text-red-400 text-center p-4">üö´ Location Error: ${message}</p>`;
    toggleKeyBtn.disabled = true;
    updateKeyButtonVisibility();
  }, { enableHighAccuracy: true });
}

async function fetchLivePoiData(lat, lon) {
    document.getElementById('places-list').innerHTML = '<p class="text-center text-blue-400 p-4 flex items-center justify-center">üåê Searching Overpass for new data... <div class="loader ml-3"></div></p>';

    const cats = Object.keys(CATEGORY_MAP); 
    const dist = document.getElementById('radius').value;
    
    const overpassQuery = `
        [out:json][timeout:25];
        (
            ${cats.map(c=>`node["${c}"](around:${dist},${lat},${lon});way["${c}"](around:${dist},${lat},${lon});`).join('')}
        );
        (
            ._;
            node(around:${dist},${lat},${lon})["name"];
        );
        out tags center geom;
    `;

    try {
        const els = await fetch("https://overpass-api.de/api/interpreter?data="+encodeURIComponent(overpassQuery))
            .then(r => r.json())
            .then(d => d.elements.filter(e => e.tags && e.tags.name));
            
        categorizedPlaces = processElements(lat, lon, els);
        
        // Save the new data to local storage
        saveLocalData({ places: categorizedPlaces, userLocation: {lat, lon} });
        
    } catch (err) {
        document.getElementById('places-list').innerHTML = `<p class="text-red-400 text-center p-4">Network Error fetching data: ${err.message}. Showing map only.</p>`;
        categorizedPlaces = {};
    }
}
</script>
</body>
</html>

