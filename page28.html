<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Mobile WebRTC Chat — QR Signaling</title>
<style>
  :root{--bg:#071021;--panel:#081223;--muted:#9aa4b2;--accent:#06b6d4;}
  html,body{height:100%;margin:0;background:var(--bg);color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto;user-select:none;touch-action:manipulation;}
  .app{height:100dvh;display:flex;flex-direction:column;padding:env(safe-area-inset-top) 14px env(safe-area-inset-bottom);box-sizing:border-box;gap:10px;}
  header{display:flex;align-items:center;justify-content:space-between;}
  h1{font-size:1.05rem;margin:0}
  .controls{display:flex;gap:8px}
  button{background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.06);color:#fff;padding:10px 14px;border-radius:10px;min-height:44px;font-size:14px;cursor:pointer}
  #log{flex:1;background:var(--panel);border-radius:12px;padding:12px;overflow-y:auto;-webkit-overflow-scrolling:touch;font-size:14px;line-height:1.4;white-space:pre-wrap}
  .composer{display:flex;gap:8px}
  input#msg{flex:1;min-height:44px;padding:10px 12px;border-radius:10px;border:none;background:rgba(255,255,255,0.02);color:#fff;font-size:15px}
  #qrWrap{display:none;background:var(--panel);border-radius:12px;padding:12px;box-sizing:border-box}
  #qrCanvas{width:100%;height:auto;display:flex;justify-content:center}
  .hint{color:var(--muted);font-size:12px;margin-top:6px}
  .small{font-size:12px;color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center}
  a.link{color:var(--accent);word-break:break-all}
  @media (min-width:700px){.app{max-width:720px;margin:0 auto}}
</style>
</head>
<body>
<div class="app">
  <header>
    <h1>Local Chat — QR Join</h1>
    <div class="controls">
      <button id="createBtn">Create Offer</button>
      <button id="toggleQrBtn">Show QR</button>
    </div>
  </header>

  <div id="qrWrap">
    <div id="qrCanvas"></div>
    <div class="row" style="margin-top:8px;">
      <button id="hideQr">Hide</button>
      <button id="copyLink">Copy Link</button>
      <div class="small" id="qrNote">Scan QR to join (or open link)</div>
    </div>
  </div>

  <div id="log">System: Not connected.</div>

  <div class="composer">
    <input id="msg" placeholder="Type a message…" />
    <button id="sendBtn">Send</button>
  </div>

  <div class="hint">Flow: Host → Create Offer → Show QR → Visitor scans → Visitor shows Answer QR → Host scans Answer → Chat established.</div>
</div>

<!-- QR library (small, CDN). If you need offline, replace with local file. -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

<script>
/* ============================
   Utility: encode / decode for SDP in URL
   ============================ */
function encodeSDP(sdp){ return encodeURIComponent(btoa(unescape(encodeURIComponent(sdp)))); }
function decodeSDP(t){ try { return decodeURIComponent(escape(atob(decodeURIComponent(t)))); } catch(e){ return null; } }

/* ============================
   DOM
   ============================ */
const logEl = document.getElementById('log');
const createBtn = document.getElementById('createBtn');
const toggleQrBtn = document.getElementById('toggleQrBtn');
const qrWrap = document.getElementById('qrWrap');
const qrCanvas = document.getElementById('qrCanvas');
const hideQr = document.getElementById('hideQr');
const copyLink = document.getElementById('copyLink');
const sendBtn = document.getElementById('sendBtn');
const msgInput = document.getElementById('msg');

/* ============================
   WebRTC local objects
   ============================ */
let pc = null;
let dataChannel = null;

/* Append lines */
function appendLine(t){ logEl.textContent += (logEl.textContent ? '\n' : '') + t; logEl.scrollTop = logEl.scrollHeight; }

/* ============================
   Create an offer (Host)
   ============================ */
async function createOfferAndShowQR(){
  appendLine('System: Creating offer...');
  pc = new RTCPeerConnection();
  dataChannel = pc.createDataChannel('chat');
  setupDataChannel(dataChannel);

  pc.onicecandidate = e => {
    // Wait until localDescription is set; we present the base SDP offer with ICE candidates that have arrived or will arrive.
    // For simplicity we will wait a short moment then display the SDP (this is manual signalling - scanning the QR after a second is typical)
  };

  pc.onconnectionstatechange = () => appendLine('Connection state: ' + pc.connectionState);

  await pc.setLocalDescription(await pc.createOffer());
  // Give ICE a short moment to gather candidates (trickle not used in QR flow)
  await new Promise(r => setTimeout(r, 800)); // small wait to collect some candidates

  const sdp = pc.localDescription.sdp;
  const token = encodeSDP(sdp);
  // Build join link with offer param
  const joinUrl = location.origin + location.pathname + '?offer=' + token;
  showQR(joinUrl);
  appendLine('System: Offer created. Show QR to let others join.');
}

/* ============================
   If page opened with ?offer=... act as callee (visitor)
   - auto create answer and display answer as QR and link for host to scan/open
   ============================ */
async function processIncomingOffer(encodedOffer){
  appendLine('System: Incoming offer detected. Preparing answer...');
  const sdpOffer = decodeSDP(encodedOffer);
  if (!sdpOffer){ appendLine('Error: Could not decode offer.'); return; }

  pc = new RTCPeerConnection();
  pc.ondatachannel = (e) => {
    dataChannel = e.channel;
    setupDataChannel(dataChannel);
  };
  pc.onconnectionstatechange = () => appendLine('Connection state: ' + pc.connectionState);

  await pc.setRemoteDescription({ type: 'offer', sdp: sdpOffer });

  // create answer
  await pc.setLocalDescription(await pc.createAnswer());
  // wait a bit for ICE
  await new Promise(r => setTimeout(r, 800));
  const answerSDP = pc.localDescription.sdp;
  const token = encodeSDP(answerSDP);
  const answerUrl = location.origin + location.pathname + '?answer=' + token;

  // show QR so host can scan it back
  showQR(answerUrl);
  appendLine('System: Answer ready — show this QR to host so they can scan to complete connection.');
}

/* ============================
   If host receives ?answer=... (when host opens link or scans answer QR)
   - set remote desc and finish
   ============================ */
async function processIncomingAnswer(encodedAnswer){
  appendLine('System: Incoming answer detected — finishing setup...');
  const sdpAnswer = decodeSDP(encodedAnswer);
  if (!sdpAnswer){ appendLine('Error: Could not decode answer.'); return; }
  if (!pc) { appendLine('Error: No local peer exists (create an offer first).'); return; }
  await pc.setRemoteDescription({ type: 'answer', sdp: sdpAnswer });
  appendLine('System: Answer applied. Connection should establish once ICE completes.');
}

/* ============================
   Setup data channel handlers
   ============================ */
function setupDataChannel(ch){
  ch.onopen = () => appendLine('System: Data channel open.');
  ch.onclose = () => appendLine('System: Data channel closed.');
  ch.onmessage = (e) => appendLine('Peer: ' + e.data);
}

/* ============================
   QR UI
   ============================ */
let qrGenerator = null;
function showQR(text){
  qrCanvas.innerHTML = '';
  qrWrap.style.display = 'block';
  toggleQrBtn.textContent = 'Hide QR';
  try {
    qrGenerator = new QRCode(qrCanvas, { text, width: 280, height: 280, correctLevel: QRCode.CorrectLevel.M });
  } catch(err){
    // fallback: show link if QR lib fails
    qrCanvas.innerHTML = '<a class="link" href="' + text + '">' + text + '</a>';
  }
  // show link for copy as well
  document.getElementById('qrNote').innerHTML = 'Link: <a class="link" href="' + text + '" target="_blank" rel="noopener">' + text + '</a>';
}

/* ============================
   Events
   ============================ */
createBtn.addEventListener('click', createOfferAndShowQR);

toggleQrBtn.addEventListener('click', () => {
  if (qrWrap.style.display === 'block'){ qrWrap.style.display = 'none'; toggleQrBtn.textContent = 'Show QR'; }
  else { qrWrap.style.display = 'block'; toggleQrBtn.textContent = 'Hide QR'; }
});

hideQr.addEventListener('click', () => { qrWrap.style.display = 'none'; toggleQrBtn.textContent = 'Show QR'; });

copyLink.addEventListener('click', () => {
  const linkText = document.querySelector('#qrNote .link')?.href;
  if (!linkText) return;
  navigator.clipboard?.writeText(linkText).then(()=> appendLine('System: Join link copied.') ).catch(()=> appendLine('System: Copy failed.'));
});

/* Send message */
sendBtn.addEventListener('click', () => {
  const t = msgInput.value.trim();
  if (!t) return;
  if (dataChannel && dataChannel.readyState === 'open') {
    dataChannel.send(t);
    appendLine('You: ' + t);
    msgInput.value = '';
  } else {
    appendLine('System: data channel not open. Make sure both sides completed QR exchange.');
  }
});
msgInput.addEventListener('keydown', e => { if (e.key === 'Enter') sendBtn.click(); });

/* ============================
   On load: handle ?offer= or ?answer= in URL
   ============================ */
(async function handleUrl(){
  const params = new URLSearchParams(location.search);
  if (params.has('offer')){
    // callee flow
    const token = params.get('offer');
    // clear search so link shown for answer won't keep offer param when shared back
    history.replaceState(null, '', location.pathname);
    await processIncomingOffer(token);
  } else if (params.has('answer')){
    const token = params.get('answer');
    history.replaceState(null, '', location.pathname);
    await processIncomingAnswer(token);
  } else {
    // no params — normal host UI
  }
})();

/* ============================
   Small UX protections (disable selection/context on non-inputs)
   ============================ */
document.addEventListener('selectstart', e => { if (!['INPUT','TEXTAREA','A'].includes(e.target.tagName)) e.preventDefault(); }, { passive:false });
document.addEventListener('contextmenu', e => { if (!e.target.closest('input')) e.preventDefault(); }, { passive:false });
document.addEventListener('dragstart', e => e.preventDefault());

</script>
</body>
</html>