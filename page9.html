<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Handoff (Auto Fallback)</title>
<style>
/* üé® UI/UX Styling for Mobile */
body {
    font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Open Sans", "Helvetica Neue", sans-serif;
    background: #0e1320; /* Dark Mode Background */
    color: #f0f4f8; /* Light Text */
    text-align: center;
    margin: 0;
    padding: 0;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
}
/* --- Navigation Bar --- */
#navbar { /* New Navigation Bar Style */
    width: 100%;
    background: #111b2a;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.4);
    padding: 10px 20px;
    box-sizing: border-box;
    position: sticky;
    top: 0;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    align-items: center;
}
#nav-title {
    font-size: 18px;
    font-weight: 700;
    color: #8cf;
}
#nav-link a {
    color: #a0a6b4;
    text-decoration: none;
    font-size: 14px;
    margin-left: 15px;
}
#nav-link a:hover {
    color: #fff;
}
/* --- Main Card Styles --- */
.card {
    width: 100%;
    max-width: 450px; 
    margin: 0;
    padding: 20px;
    box-sizing: border-box;
    background: #111b2a; 
    border-radius: 0 0 20px 20px; 
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
}
h2 {
    margin: 0 0 10px 0;
    font-weight: 600;
    color: #8cf; 
}
.user-info {
    font-size: 16px;
    font-weight: 500;
    margin-bottom: 5px;
}
.status-bar {
    margin-bottom: 20px;
    font-size: 14px;
    color: #a0a6b4;
    height: 20px; 
}
.action-row {
    display: flex;
    gap: 10px;
    margin-bottom: 15px;
}
.action-row input, .action-row button {
    flex-grow: 1;
    padding: 10px 12px;
    border-radius: 8px;
    border: 1px solid #334;
    background: #18233a;
    color: #eee;
    font-size: 16px;
    box-sizing: border-box;
    cursor: pointer;
}
.action-row button#connect-ws {
    background: #4a75a7; /* Blue for connection */
    border: none;
}
.action-row button#connect-ws:disabled {
    background: #233144;
    color: #a0a6b4;
}


/* üñºÔ∏è Peer List Design */
.peerlist-container {
    background: #0c1525;
    border-radius: 12px;
    padding: 10px;
    margin-bottom: 20px;
    box-shadow: inset 0 0 8px rgba(0, 0, 0, 0.3);
}
.peerlist-header {
    font-size: 14px;
    color: #a0a6b4;
    text-align: left;
    margin-bottom: 5px;
    font-weight: 500;
}
.peerlist {
    max-height: 150px;
    overflow-y: auto;
    padding-right: 5px; 
}
.peer {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #233144;
    padding: 8px 0;
}
.peer:last-child {
    border-bottom: none;
}
.peer-name {
    font-weight: 500;
    text-align: left;
    flex-grow: 1;
}
.connect-btn {
    padding: 6px 12px;
    border-radius: 20px;
    border: none;
    background: #4CAF50; /* Green connect button for peer */
    color: #fff;
    font-weight: 600;
    font-size: 14px;
    cursor: pointer;
    transition: background 0.2s;
}
.connect-btn:hover {
    background: #66BB6A;
}
.connected-text {
    color: #8cf; /* Light blue for connected peer */
    font-size: 14px;
    font-weight: 600;
}

/* üì§ Split File Drop Zone */
#drop-container {
    margin-top: 20px;
    border: 2px dashed #345e8f; /* Main border */
    border-radius: 15px;
    overflow: hidden; /* Contains the split sections */
    display: flex;
    flex-direction: row; /* Split horizontally for mobile */
}
.drop-zone {
    flex: 1;
    padding: 20px 10px;
    background: #142034;
    cursor: pointer;
    transition: background 0.2s;
}
.drop-zone:first-child {
    border-right: 1px dashed #345e8f; /* Split line */
}
.drop-zone:hover {
    background: #1b2841;
}
.drop-zone strong {
    display: block;
    margin-bottom: 5px;
    color: #8cf; /* Blue for the main call to action */
}
.drop-zone small {
    display: block;
    color: #a0a6b4;
}
#file {
    display: none; 
}
progress {
    width: 100%;
    margin-top: 15px;
    height: 8px;
    border-radius: 4px;
    -webkit-appearance: none;
    appearance: none;
}
progress::-webkit-progress-bar {
    background-color: #334;
    border-radius: 4px;
}
progress::-webkit-progress-value {
    background-color: #8cf; 
    border-radius: 4px;
}
a.download {
    display: block;
    margin-top: 15px;
    padding: 10px;
    background: #4CAF50;
    color: white;
    border-radius: 8px;
    text-decoration: none;
    font-weight: 600;
}

/* --- About Us Card --- */
.about-card {
    width: 100%;
    max-width: 450px;
    margin: 20px 0;
    padding: 20px;
    box-sizing: border-box;
    background: #111b2a;
    border-radius: 12px;
    text-align: left;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
}
.about-card h3 {
    color: #4CAF50;
    margin-top: 0;
    border-bottom: 1px solid #233144;
    padding-bottom: 8px;
}
.about-card p {
    margin-bottom: 15px;
    line-height: 1.5;
}
.about-card ul {
    list-style: disc;
    margin-left: 20px;
    padding-left: 0;
}
.about-card li {
    margin-bottom: 5px;
}
</style>
</head>
<body>
<!-- NEW NAVIGATION BAR (Add Bars to the Thing) -->
<nav id="navbar">
    <span id="nav-title">Handoff</span>
    <div id="nav-link">
        <a href="#about-us-section">About</a>
    </div>
</nav>

<div class="card">
    <h2>Handoff (Auto Fallback)</h2>
    
    <div class="user-info">Logged in as: <span id="display-name">Loading...</span></div>
    <div class="status-bar" id="status">Ready. Click Connect.</div>

    <div class="action-row">
        <input id="name" placeholder="Your name (e.g., My Phone)" value="">
        <button id="connect-ws">Connect</button>
    </div>

    <div class="peerlist-container">
        <div class="peerlist-header">Nearby Devices (Connect to Peer)</div>
        <div class="peerlist" id="peers">Not connected to server...</div>
    </div>

    <div id="drop-container">
        <label for="file" class="drop-zone">
            <strong>Tap to Send File</strong>
            <small>Select from storage</small>
            <input type="file" id="file" multiple>
        </label>
        <label for="file-camera" class="drop-zone">
            <strong>Tap to Take Photo</strong>
            <small>Use your camera</small>
            <input type="file" id="file-camera" accept="image/*" capture="camera" style="display:none;">
        </label>
    </div>

    <progress id="progress" value="0" max="1"></progress>
</div>

<!-- NEW ABOUT US SECTION -->
<div id="about-us-section" class="about-card">
    <h3>About Handoff: Secure, Peer-to-Peer Sharing</h3>
    
    <p>
        Our mission is to enable the **fastest, most reliable local file sharing possible**, free from cloud storage limitations and unnecessary network hurdles. Handoff facilitates true device-to-device communication.
    </p>
    
    <h4>Business & Technology Focus</h4>
    <ul>
        <li>**P2P Focus:** Handoff is built entirely on WebRTC technology, ensuring data is transferred directly between your browser and your peer's browser.</li>
        <li>**Privacy:** File data *never* touches our signaling servers. Only basic connection information (like your random name) is exchanged to set up the peer-to-peer link.</li>
        <li>**Free and Open:** Handoff is a free-to-use, open-source concept, emphasizing secure, fast, and local connectivity.</li>
    </ul>
</div>


<script>
(()=>{
// List of public signaling servers to cycle through if one fails (6 Servers)
const SIGNALING_SERVERS = [
    "wss://ws.shizq.xyz", 
    "wss://webrtc-signaling.glitch.me", 
    "wss://webrtc-signaling.com/ws",
    "wss://cloudflare-rtc.glitch.me",
    "wss://relay.signalhub.online",
    "wss://websocket.s-h.xyz"
];
let ws, name, peers={}, pc, dc, target;
let serverIndex = 0; // Current index in the SIGNALING_SERVERS array

const peersDiv=document.getElementById("peers"),progress=document.getElementById("progress"),status=document.getElementById("status"), nameInput=document.getElementById("name"), displayName=document.getElementById("display-name"), connectButton=document.getElementById("connect-ws");

// --- UTILITY FUNCTIONS ---

function generateRandomName() {
    return "anon-" + Math.floor(Math.random() * 9999);
}

function log(t, color){
    status.textContent=t;
    if (color) status.style.color = color;
    else status.style.color = '#a0a6b4';
}

function setDisconnectedUI() {
    nameInput.disabled = false;
    connectButton.disabled = false;
    connectButton.textContent = "Connect";
    connectButton.style.backgroundColor = '#4a75a7';
    peersDiv.textContent="Not connected to server...";
}

// --- MAIN LOGIC (Server Connection Loop) ---

function start(){
    // Stop if we ran out of servers to try
    if (serverIndex >= SIGNALING_SERVERS.length) {
        log("Connection failed: All available public servers tried.", 'red');
        setDisconnectedUI();
        return;
    }

    const currentServer = SIGNALING_SERVERS[serverIndex];

    // Use current input value, or fallback to a new random one
    name=nameInput.value.trim() || generateRandomName();
    displayName.textContent = name;
    
    // 1. Attempt connection (Synchronous part)
    try {
        ws = new WebSocket(currentServer);
    } catch(e) {
        // Only catches invalid URL format, not network failure
        console.error("Synchronous WebSocket Error (Trying next server):", e);
        serverIndex++;
        // Use a timeout to retry immediately with the next server
        setTimeout(start, 50); 
        return;
    }

    connectButton.disabled = true;
    log(`Connecting to Server #${serverIndex + 1}...`, '#8cf');

    // 2. Event Handlers (Asynchronous success/failure)

    ws.onopen=()=>{
        // SUCCESS: Clear fail index
        serverIndex = 0; 
        ws.send(JSON.stringify({join:true,name}));
        log(`Connected to Server #${serverIndex + 1}. Ready to find peers.`, '#4CAF50');
        nameInput.disabled = true; 
        connectButton.textContent = "Connected";
        connectButton.style.backgroundColor = '#4CAF50';
    }

    const handleErrorOrClose = (e) => {
        // If the connection was OPEN when this fired, it's a disconnect.
        if (ws && ws.readyState === WebSocket.OPEN) {
            log("Disconnected from server. Click Connect to retry.", 'red');
            setDisconnectedUI();
            return;
        }

        // If failure during connection attempt (readyState is CONNECTING or CLOSING), try the next server
        serverIndex++;
        
        if (serverIndex < SIGNALING_SERVERS.length) {
            log(`Connection to Server #${serverIndex} failed. Trying Server #${serverIndex + 1}...`, 'red');
            // Wait a moment before trying the next server
            setTimeout(start, 250); 
        } else {
            log("Connection failed: All available public servers tried.", 'red');
            setDisconnectedUI();
        }
    }

    // These events act as the asynchronous "catch"
    ws.onclose = handleErrorOrClose;
    ws.onerror = handleErrorOrClose;


    ws.onmessage=(e)=>{const m=JSON.parse(e.data);
        if(m.list){renderPeers(m.list);} 
        else if(m.offer){handleOffer(m);}
        else if(m.answer){pc&&pc.setRemoteDescription(m.answer);}
        else if(m.ice){pc&&pc.addIceCandidate(m.ice);}
    };
}

// --- PEER CONNECTION LOGIC ---

function renderPeers(list){
    peersDiv.innerHTML='';
    const filteredList = list.filter(p=>p!==name);
    
    if(filteredList.length === 0) {
        peersDiv.textContent="No other devices found yet.";
        return;
    }

    filteredList.forEach(p=>{
        const d=document.createElement('div');
        d.className='peer';
        
        const isConnected = (p === target && dc && dc.readyState === "open");
        
        const actionHtml = isConnected 
            ? `<span class="connected-text">Peer Connected</span>`
            : `<button class="connect-btn" data-peer="${p}">Connect</button>`;
            
        d.innerHTML=`<span class="peer-name">${p}</span>${actionHtml}`;
        
        const connectPeerButton = d.querySelector('.connect-btn');
        if (connectPeerButton) {
            connectPeerButton.onclick=()=>connectTo(p);
        }

        peersDiv.appendChild(d);
    });
}

async function connectTo(peer){
    if(pc) pc.close();
    target=peer;
    
    // WebRTC connection setup
    pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    dc=pc.createDataChannel('file');
    setupDC();
    
    pc.onicecandidate=e=>{if(e.candidate)ws.send(JSON.stringify({to:peer,ice:e.candidate}));};
    const offer=await pc.createOffer();await pc.setLocalDescription(offer);
    ws.send(JSON.stringify({to:peer,offer}));
    log("Sending peer connection request to "+peer+"...", '#FFC107');
    
    ws.send(JSON.stringify({list:true}));
}

function setupDC(){
    dc.binaryType='arraybuffer';
    dc.onopen=()=>{
        log("Peer connected: "+target, '#8cf');
        ws.send(JSON.stringify({list:true})); 
    }
    dc.onclose=()=>log("Peer connection closed with "+target);
    dc.onerror=(e)=>log("Peer error: "+e.error.message, 'red');
    
    let meta=null,received=[],bytes=0;
    dc.onmessage=e=>{
        if(typeof e.data==="string"){
            try{const j=JSON.parse(e.data);
                if(j.meta){
                    meta=j.meta;received=[];bytes=0;
                    progress.value=0;progress.max=j.meta.size;
                    log(`Receiving ${meta.name} (${(meta.size/1024/1024).toFixed(1)} MB)`, '#8cf');
                    
                    document.querySelectorAll('.download').forEach(a=>a.remove());
                }
            }catch{}
        }else{
            received.push(e.data);bytes+=e.data.byteLength;progress.value=bytes;
            if(bytes>=meta.size){
                const blob=new Blob(received, {type: meta.type});
                const a=document.createElement('a');
                a.href=URL.createObjectURL(blob);a.download=meta.name;
                a.textContent=`Download '${meta.name}'`;a.className="download";
                document.querySelector(".card").appendChild(a);
                log("File received successfully!", '#4CAF50');
            }
        }
    };
}

async function handleOffer(m){
    target=m.from;
    pc=new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    pc.onicecandidate=e=>{if(e.candidate)ws.send(JSON.stringify({to:m.from,ice:e.candidate}));};
    pc.ondatachannel=e=>{dc=e.channel;setupDC();};
    
    await pc.setRemoteDescription(m.offer);
    const ans=await pc.createAnswer();await pc.setLocalDescription(ans);
    ws.send(JSON.stringify({to:m.from,answer:ans}));
    log("Accepted connection from "+m.from, '#8cf');
}

// --- FILE SENDING LOGIC ---

const fileInputHandler = e => {
    const f=e.target.files[0];
    e.target.value = '';
    if(f) sendFile(f);
};

document.getElementById("file").onchange=fileInputHandler;
document.getElementById("file-camera").onchange=fileInputHandler;

connectButton.onclick=()=>{
    // Reset index to 0 when user manually clicks Connect
    serverIndex = 0; 
    start();
};

const dropContainer=document.getElementById("drop-container");
dropContainer.ondragover=e=>{e.preventDefault();dropContainer.style.opacity=0.8};
dropContainer.ondragleave=e=>{dropContainer.style.opacity=1};
dropContainer.ondrop=e=>{
    e.preventDefault();dropContainer.style.opacity=1;
    const f=e.dataTransfer.files[0];if(f)sendFile(f);
};

async function sendFile(file){
    if(!dc||dc.readyState!=="open"){
        log("Connection required to send file. Please connect to a device.", '#FFC107');
        return;
    }
    log(`Sending ${file.name} to ${target}...`, '#8cf');
    progress.max=file.size;progress.value=0;
    
    dc.send(JSON.stringify({meta:{name:file.name,size:file.size,type:file.type}}));
    
    const stream=file.stream();const reader=stream.getReader();
    while(true){
        const {done,value}=await reader.read();if(done)break;
        dc.send(value);
        progress.value+=value.byteLength;
        if(dc.bufferedAmount>512000)await new Promise(r=>setTimeout(r,50));
    }
    log("File sent successfully!", '#4CAF50');
}

// üöÄ INITIALIZATION
window.onload = () => {
    const defaultName = generateRandomName();
    nameInput.value = defaultName;
    displayName.textContent = defaultName;
    nameInput.addEventListener('input', () => {
        displayName.textContent = nameInput.value.trim() || generateRandomName();
    });
};

})();
</script>
</body>
</html>


